exporters:
  otlp:
    endpoint: ${OTEL_ENVOY_ADDRESS}
    tls:
      insecure: ${OTEL_ENVOY_ADDRESS_TLS_INSECURE}
    headers:
      "Authorization": "Bearer ${SOLARWINDS_API_TOKEN}"
      "swi-reporter": "k8s-monitoring swo-k8s-collector/{{ .Chart.Version }}"
    retry_on_failure:
      enabled: {{ .Values.otel.gateway.retry_on_failure.enabled }}
      initial_interval: {{ .Values.otel.gateway.retry_on_failure.initial_interval }}
      max_interval: {{ .Values.otel.gateway.retry_on_failure.max_interval }}
      max_elapsed_time: {{ .Values.otel.gateway.retry_on_failure.max_elapsed_time }}
    sending_queue:
      enabled: {{ .Values.otel.gateway.sending_queue.enabled }}
      num_consumers: {{ .Values.otel.gateway.sending_queue.num_consumers }}
      queue_size: {{ .Values.otel.gateway.sending_queue.queue_size }}
{{- if .Values.otel.gateway.sending_queue.offload_to_disk }}
      storage: file_storage/sending_queue
{{- end }}
    timeout: {{ .Values.otel.gateway.timeout }}

extensions:
{{- if .Values.otel.gateway.sending_queue.offload_to_disk }}
  file_storage/sending_queue:
    directory: /var/lib/swo/sending_queue
    fsync: true
{{- end }}
  health_check:
    endpoint: 0.0.0.0:13133
{{- if .Values.diagnostics.profiling.enabled }}
  pprof:
    endpoint: localhost:{{ .Values.diagnostics.profiling.port }}
{{- end }}

processors:
  batch:
{{ toYaml .Values.otel.gateway.batch | indent 4 }}

  memory_limiter:
{{ toYaml .Values.otel.gateway.memory_limiter | indent 4 }}

  k8sattributes:
{{ include "common.k8s-instrumentation" . | indent 4 }}

  metricstransform/rename-following-otel-semantics:
    transforms:
{{ include "common-config.metricstransform-rename" .Values.otel.gateway.prefix | indent 6 }}

  resource:
    attributes:
      # Collector and Manifest version
      - key: sw.k8s.agent.manifest.version
        value: ${MANIFEST_VERSION}
        action: insert

      - key: sw.k8s.agent.app.version
        value: ${APP_VERSION}
        action: insert

      # Cluster
      - key: sw.k8s.cluster.uid
        value: ${CLUSTER_UID}
        action: insert

      - key: k8s.cluster.name
        value: ${CLUSTER_NAME}
        action: upsert

  resource/clean-temporary-attributes:
    attributes:      
      - key: obi
        action: delete
      - key: tcp
        action: delete
      - key: http
        action: delete
      - key: grpc
        action: delete
      - key: sw.k8s.dst.workload.name
        action: delete
      - key: sw.k8s.dst.workload.namespace
        action: delete
      - key: sw.k8s.dst.workload.type
        action: delete
      - key: sw.k8s.src.workload.name
        action: delete
      - key: sw.k8s.src.workload.namespace
        action: delete
      - key: sw.k8s.src.workload.type
        action: delete
      - key: sw.k8s.workload.name
        action: delete
      - key: sw.k8s.workload.namespace
        action: delete
      - key: sw.k8s.workload.type
        action: delete

  # Those attributes are defined by SWO K8s Collector even if they are send as attributes in OTLP message
  attributes/clean-attributes-otlp-metrics:
    actions:
      - key: k8s.cluster.name
        action: delete

  transform/scope:
    metric_statements:
      - statements:
        - set(scope.name, "")
        - set(scope.version, "")
    log_statements:
      - statements:
        - set(scope.name, "")
        - set(scope.version, "")
    trace_statements:
      - statements:
        - set(scope.name, "")
        - set(scope.version, "")

  filter/otlp-metrics:
    metrics:
      metric:
        # metrics from EBPF reducer that are not needed
        - 'IsMatch(name, "^ebpf_net.*$")'
{{- if .Values.otel.metrics.filter_histograms }}
  filter/histograms:
    metrics:
      metric:
        - 'type == METRIC_DATA_TYPE_HISTOGRAM'
{{- end }}

  transform/obi-keep-only-entity-relation-attributes:
    metric_statements:
      - keep_matching_keys(resource.attributes, "^(sw\\.k8s\\.cluster\\.uid)|(source\\..*)|(dest\\..*)|(obi)|(tcp)|(http)|(grpc)$")

  swok8sworkloadtype/obi:
    workload_mappings:
      - name_attr: k8s.src.owner.name
        namespace_attr: k8s.src.namespace
        workload_type_attr: sw.k8s.src.workload.type
        workload_name_attr: sw.k8s.src.workload.name
        workload_namespace_attr: sw.k8s.src.workload.namespace
        prefer_owner_for_pods: true
        expected_types:
          - deployments
          - daemonsets
          - statefulsets
          - services
          - jobs
          - cronjobs
          - pods
          - nodes
      - name_attr: k8s.dst.owner.name
        namespace_attr: k8s.dst.namespace
        workload_type_attr: sw.k8s.dst.workload.type
        workload_name_attr: sw.k8s.dst.workload.name
        workload_namespace_attr: sw.k8s.dst.workload.namespace
        prefer_owner_for_pods: true
        expected_types:
          - deployments
          - daemonsets
          - statefulsets
          - services
          - jobs
          - cronjobs
          - pods
          - nodes
      - name_attr: resource.k8s.owner.name
        namespace_attr: resource.k8s.namespace.name
        workload_type_attr: resource.sw.k8s.workload.type
        workload_name_attr: resource.sw.k8s.workload.name
        workload_namespace_attr: resource.sw.k8s.workload.namespace
        prefer_owner_for_pods: true
        expected_types:
          - deployments
          - daemonsets
          - statefulsets
          - services
          - jobs
          - cronjobs
          - pods
          - nodes
      - address_attr: server.address
        namespace_attr: k8s.namespace.name
        workload_type_attr: sw.k8s.dst.workload.type
        workload_name_attr: sw.k8s.dst.workload.name
        workload_namespace_attr: sw.k8s.dst.workload.namespace
        prefer_owner_for_pods: true
        expected_types:
          - deployments
          - daemonsets
          - statefulsets
          - services
          - jobs
          - cronjobs
          - pods
          - nodes
      - address_attr: client.address
        namespace_attr: k8s.namespace.name
        workload_type_attr: sw.k8s.src.workload.type
        workload_name_attr: sw.k8s.src.workload.name
        workload_namespace_attr: sw.k8s.src.workload.namespace
        prefer_owner_for_pods: true
        expected_types:
          - deployments
          - daemonsets
          - statefulsets
          - services
          - jobs
          - cronjobs
          - pods
          - nodes

  transform/obi-fqdn-attribute:
    metric_statements:
      - statements:
          # The logic of what shapes of addresses are considered FQDNs should match 'transform/istio-metric-datapoints'.
          - set(datapoint.attributes["dest.sw.server.address.fqdn"], datapoint.attributes["server.address"]) where IsMatch(metric.name, "^http\\.client\\.") and datapoint.attributes["sw.k8s.dst.workload.type"] == nil and IsMatch(datapoint.attributes["server.address"], "^(https?://)?[a-zA-Z0-9][-a-zA-Z0-9]*\\.[a-zA-Z0-9][-a-zA-Z0-9\\.]*(:\\d+)?$") and not(IsMatch(datapoint.attributes["server.address"], ".*\\.cluster\\.local\\.?$")) and not(IsMatch(datapoint.attributes["server.address"], "^(https?://)?\\d+\\.\\d+\\.\\d+\\.\\d+(:\\d+)?$"))
          # Replace port in FQDN if present (PublicNetworkLocation entity must not include port)
          - replace_pattern(datapoint.attributes["dest.sw.server.address.fqdn"], "^(https?://)?([^/:]+)(:\\d+)?$", "$$2") where datapoint.attributes["dest.sw.server.address.fqdn"] != nil
          # OBI prefers filling 'client.address' attributes with OTEL Service name (or name + k8s namespace) instead of an actual FQDN, when possible. This makes this value useless for us because they would create fake FQDNs.
          # - set(datapoint.attributes["source.sw.server.address.fqdn"], datapoint.attributes["client.address"]) where IsMatch(metric.name, "^http\\.server\\.") and datapoint.attributes["sw.k8s.src.workload.type"] == nil and IsMatch(datapoint.attributes["client.address"], "^(https?://)?[a-zA-Z0-9][-a-zA-Z0-9]*\\.[a-zA-Z0-9][-a-zA-Z0-9\\.]*(:\\d+)?$") and not(IsMatch(datapoint.attributes["client.address"], ".*\\.cluster\\.local$")) and not(IsMatch(datapoint.attributes["client.address"], "^(https?://)?\\d+\\.\\d+\\.\\d+\\.\\d+(:\\d+)?$"))
          # While 'dst.address' and 'src.adderess' contain an actual address, in practice they often contain an IP address, which we currently do not want to use as an FQDN.
          - set(datapoint.attributes["dest.sw.server.address.fqdn"], datapoint.attributes["dst.address"]) where IsMatch(metric.name, "^obi\\.network\\.") and datapoint.attributes["sw.k8s.dst.workload.type"] == nil and IsMatch(datapoint.attributes["dst.address"], "^(https?://)?[a-zA-Z0-9][-a-zA-Z0-9]*\\.[a-zA-Z0-9][-a-zA-Z0-9\\.]*(:\\d+)?$") and not(IsMatch(datapoint.attributes["dst.address"], ".*\\.cluster\\.local$")) and not(IsMatch(datapoint.attributes["dst.address"], "^(https?://)?\\d+\\.\\d+\\.\\d+\\.\\d+(:\\d+)?$"))
          - set(datapoint.attributes["source.sw.server.address.fqdn"], datapoint.attributes["src.address"]) where IsMatch(metric.name, "^obi\\.network\\.") and datapoint.attributes["sw.k8s.src.workload.type"] == nil and IsMatch(datapoint.attributes["src.address"], "^(https?://)?[a-zA-Z0-9][-a-zA-Z0-9]*\\.[a-zA-Z0-9][-a-zA-Z0-9\\.]*(:\\d+)?$") and not(IsMatch(datapoint.attributes["src.address"], ".*\\.cluster\\.local$")) and not(IsMatch(datapoint.attributes["src.address"], "^(https?://)?\\d+\\.\\d+\\.\\d+\\.\\d+(:\\d+)?$"))

          # Temporary, to be removed when solarwindsentityconnector supports creation of entities from attributes with prefixes
          - set(datapoint.attributes["sw.server.address.fqdn"], datapoint.attributes["dest.sw.server.address.fqdn"]) where datapoint.attributes["dest.sw.server.address.fqdn"] != nil
          - set(datapoint.attributes["sw.server.address.fqdn"], datapoint.attributes["source.sw.server.address.fqdn"]) where datapoint.attributes["source.sw.server.address.fqdn"] != nil

  transform/obi-entity-ids:
    metric_statements:
      # source workload detected by the workloadtype processor
      - conditions:
          - resource.attributes["sw.k8s.src.workload.name"] != nil
        statements:
          - set(resource.attributes["source.k8s.deployment.name"], resource.attributes["sw.k8s.src.workload.name"]) where resource.attributes["sw.k8s.src.workload.type"] == "Deployment"
          - set(resource.attributes["source.k8s.statefulset.name"], resource.attributes["sw.k8s.src.workload.name"]) where resource.attributes["sw.k8s.src.workload.type"] == "StatefulSet"
          - set(resource.attributes["source.k8s.daemonset.name"], resource.attributes["sw.k8s.src.workload.name"]) where resource.attributes["sw.k8s.src.workload.type"] == "DaemonSet"
          - set(resource.attributes["source.k8s.service.name"], resource.attributes["sw.k8s.src.workload.name"]) where resource.attributes["sw.k8s.src.workload.type"] == "Service"
          - set(resource.attributes["source.k8s.job.name"], resource.attributes["sw.k8s.src.workload.name"]) where resource.attributes["sw.k8s.src.workload.type"] == "Job"
          - set(resource.attributes["source.k8s.node.name"], resource.attributes["sw.k8s.src.workload.name"]) where resource.attributes["sw.k8s.src.workload.type"] == "Node"
          - set(resource.attributes["source.k8s.pod.name"], resource.attributes["sw.k8s.src.workload.name"]) where resource.attributes["sw.k8s.src.workload.type"] == "Pod"
      - statements:
          - set(resource.attributes["source.k8s.namespace.name"], resource.attributes["sw.k8s.src.workload.namespace"]) where resource.attributes["sw.k8s.src.workload.namespace"] != nil

      # dest workload detected by the workloadtype processor
      - conditions:
          - resource.attributes["sw.k8s.dst.workload.name"] != nil
        statements:
          - set(resource.attributes["dest.k8s.deployment.name"], resource.attributes["sw.k8s.dst.workload.name"]) where resource.attributes["sw.k8s.dst.workload.type"] == "Deployment"
          - set(resource.attributes["dest.k8s.statefulset.name"], resource.attributes["sw.k8s.dst.workload.name"]) where resource.attributes["sw.k8s.dst.workload.type"] == "StatefulSet"
          - set(resource.attributes["dest.k8s.daemonset.name"], resource.attributes["sw.k8s.dst.workload.name"]) where resource.attributes["sw.k8s.dst.workload.type"] == "DaemonSet"
          - set(resource.attributes["dest.k8s.service.name"], resource.attributes["sw.k8s.dst.workload.name"]) where resource.attributes["sw.k8s.dst.workload.type"] == "Service"
          - set(resource.attributes["dest.k8s.job.name"], resource.attributes["sw.k8s.dst.workload.name"]) where resource.attributes["sw.k8s.dst.workload.type"] == "Job"
          - set(resource.attributes["dest.k8s.node.name"], resource.attributes["sw.k8s.dst.workload.name"]) where resource.attributes["sw.k8s.dst.workload.type"] == "Node"
          - set(resource.attributes["dest.k8s.pod.name"], resource.attributes["sw.k8s.dst.workload.name"]) where resource.attributes["sw.k8s.dst.workload.type"] == "Pod"
      - statements:
          - set(resource.attributes["dest.k8s.namespace.name"], resource.attributes["sw.k8s.dst.workload.namespace"]) where resource.attributes["sw.k8s.dst.workload.namespace"] != nil

      # as a fallback for the above, if the "sw.k8s.src.workload.name" was not determined, use the "sw.k8s.workload.name" for source of client metrics
      - conditions:
          - resource.attributes["sw.k8s.src.workload.name"] == nil and resource.attributes["sw.k8s.workload.name"] != nil and (IsMatch(metric.name, "^(http\\.client\\.)|(rpc\\.client\\.)") or (metric.name == "obi.network.flow.bytes" and datapoint.attributes["direction"] == "request"))
        statements:
          - set(datapoint.attributes["source.k8s.deployment.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Deployment"
          - set(datapoint.attributes["source.k8s.statefulset.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "StatefulSet"
          - set(datapoint.attributes["source.k8s.daemonset.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "DaemonSet"
          - set(datapoint.attributes["source.k8s.service.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Service"
          - set(datapoint.attributes["source.k8s.job.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Job"
          - set(datapoint.attributes["source.k8s.node.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Node"
          - set(datapoint.attributes["source.k8s.pod.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Pod"
      - statements:
          - set(datapoint.attributes["source.k8s.namespace.name"], resource.attributes["sw.k8s.workload.namespace"]) where resource.attributes["source.k8s.namespace.name"] == nil and resource.attributes["sw.k8s.workload.namespace"] != nil and (IsMatch(metric.name, "^(http\\.client\\.)|(rpc\\.client\\.)") or metric.name == "obi.network.flow.bytes" and datapoint.attributes["direction"] == "request")

      # as a fallback for the above, if the "sw.k8s.dst.workload.name" was not determined, use the "sw.k8s.workload.name" for dest of server metrics
      - conditions:
          - resource.attributes["sw.k8s.dst.workload.name"] == nil and resource.attributes["sw.k8s.workload.name"] != nil and (IsMatch(metric.name, "^(http\\.server\\.)|(rpc\\.server\\.)") or (metric.name == "obi.network.flow.bytes" and datapoint.attributes["direction"] == "response"))
        statements:
          - set(datapoint.attributes["dest.k8s.deployment.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Deployment"
          - set(datapoint.attributes["dest.k8s.statefulset.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "StatefulSet"
          - set(datapoint.attributes["dest.k8s.daemonset.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "DaemonSet"
          - set(datapoint.attributes["dest.k8s.service.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Service"
          - set(datapoint.attributes["dest.k8s.job.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Job"
          - set(datapoint.attributes["dest.k8s.node.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Node"
          - set(datapoint.attributes["dest.k8s.pod.name"], resource.attributes["sw.k8s.workload.name"]) where resource.attributes["sw.k8s.workload.type"] == "Pod"
      - statements:
          - set(datapoint.attributes["dest.k8s.namespace.name"], resource.attributes["sw.k8s.workload.namespace"]) where resource.attributes["dest.k8s.namespace.name"] == nil and resource.attributes["sw.k8s.workload.namespace"] != nil and (IsMatch(metric.name, "^(http\\.server\\.)|(rpc\\.server\\.)") or metric.name == "obi.network.flow.bytes" and datapoint.attributes["direction"] == "response")

      # mark all metrics processed by this pipeline as OBI metrics
      - statements:
          - set(resource.attributes["obi"], "true")

  transform/obi-relationship-types:
    metric_statements:
      - set(datapoint.attributes["tcp"], "true") where metric.name == "obi.network.flow.bytes"
      - set(datapoint.attributes["http"], "true") where IsMatch(metric.name, "^http\\.")
      - set(datapoint.attributes["grpc"], "true") where IsMatch(metric.name, "^rpc\\.")

  groupbyattrs/obi-relationship-types:
    keys:
      - tcp
      - http
      - grpc

  groupbyattrs/obi-entity-ids:
    keys:
      - dest.sw.server.address.fqdn
      - source.sw.server.address.fqdn
      - sw.server.address.fqdn
      - sw.k8s.dst.workload.type
      - sw.k8s.dst.workload.name
      - sw.k8s.dst.workload.namespace
      - sw.k8s.src.workload.type
      - sw.k8s.src.workload.name
      - sw.k8s.src.workload.namespace

  groupbyattrs/obi-entity-ids-after-transform:
    keys:
      - source.k8s.deployment.name
      - source.k8s.statefulset.name
      - source.k8s.daemonset.name
      - source.k8s.service.name
      - source.k8s.job.name
      - source.k8s.node.name
      - source.k8s.pod.name
      - source.k8s.namespace.name
      - dest.k8s.deployment.name
      - dest.k8s.statefulset.name
      - dest.k8s.daemonset.name
      - dest.k8s.service.name
      - dest.k8s.job.name
      - dest.k8s.node.name
      - dest.k8s.pod.name
      - dest.k8s.namespace.name

  filter/obi-self-loop-relationships:
    error_mode: ignore
    metrics:
      datapoint:
        # filter self-loops by checking if source and dest workload names match in the same namespace
        - |
          (
            (resource.attributes["source.k8s.deployment.name"] == resource.attributes["dest.k8s.deployment.name"] and resource.attributes["source.k8s.deployment.name"] != nil) or
            (resource.attributes["source.k8s.statefulset.name"] == resource.attributes["dest.k8s.statefulset.name"] and resource.attributes["source.k8s.statefulset.name"] != nil) or
            (resource.attributes["source.k8s.daemonset.name"] == resource.attributes["dest.k8s.daemonset.name"] and resource.attributes["source.k8s.daemonset.name"] != nil) or
            (resource.attributes["source.k8s.service.name"] == resource.attributes["dest.k8s.service.name"] and resource.attributes["source.k8s.service.name"] != nil) or
            (resource.attributes["source.k8s.job.name"] == resource.attributes["dest.k8s.job.name"] and resource.attributes["source.k8s.job.name"] != nil) or
            (resource.attributes["source.k8s.pod.name"] == resource.attributes["dest.k8s.pod.name"] and resource.attributes["source.k8s.pod.name"] != nil) or
            (resource.attributes["source.k8s.node.name"] == resource.attributes["dest.k8s.node.name"] and resource.attributes["source.k8s.node.name"] != nil)
          ) and (
            resource.attributes["source.k8s.namespace.name"] == resource.attributes["dest.k8s.namespace.name"] and resource.attributes["source.k8s.namespace.name"] != nil
          )

  logdedup/solarwindsentity: {}

receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:{{ .Values.otel.gateway.otlp_endpoint.port }}
      http:
        endpoint: 0.0.0.0:{{ .Values.otel.gateway.otlp_endpoint.http_port }}

connectors:
  forward/metrics_common: {}
  forward/obi-relationships: {}
  routing/metrics:
    default_pipelines: [metrics]
    table:
      - context: metric
        pipelines:
          - metrics/obi-network-entities-and-relationships
        condition: |
          name == "http.client.request.duration" or
          name == "http.client.request.body.size" or
          name == "http.client.response.body.size" or
          name == "http.server.request.duration" or 
          name == "http.server.request.body.size" or
          name == "http.server.response.body.size" or
          name == "rpc.client.duration" or 
          name == "rpc.server.duration" or 
          name == "obi.network.flow.bytes"

  solarwindsentity/obi-relationships:
    source_prefix: "source."
    destination_prefix: "dest."
    schema:
      entities:
        - entity: KubernetesDeployment
          id:
            - sw.k8s.cluster.uid
            - k8s.namespace.name
            - k8s.deployment.name
        - entity: KubernetesStatefulSet
          id:
            - sw.k8s.cluster.uid
            - k8s.namespace.name
            - k8s.statefulset.name
        - entity: KubernetesDaemonSet
          id:
            - sw.k8s.cluster.uid
            - k8s.namespace.name
            - k8s.daemonset.name
        - entity: KubernetesJob
          id:
            - sw.k8s.cluster.uid
            - k8s.namespace.name
            - k8s.job.name
        - entity: KubernetesCronJob
          id:
            - sw.k8s.cluster.uid
            - k8s.namespace.name
            - k8s.cronjob.name
        - entity: KubernetesService
          id:
            - sw.k8s.cluster.uid
            - k8s.namespace.name
            - k8s.service.name
        - entity: KubernetesPod
          id:
            - sw.k8s.cluster.uid
            - k8s.namespace.name
            - k8s.pod.name
        - entity: KubernetesNode
          id:
            - sw.k8s.cluster.uid
            - k8s.node.name
        - entity: PublicNetworkLocation
          id:
            - sw.server.address.fqdn
      events:
        relationships:
          # source KubernetesDeployment
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDeployment
            destination_entity: KubernetesService
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDeployment
            destination_entity: PublicNetworkLocation
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDeployment
            destination_entity: KubernetesDeployment
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDeployment
            destination_entity: KubernetesStatefulSet
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDeployment
            destination_entity: KubernetesDaemonSet
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDeployment
            destination_entity: KubernetesNode
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDeployment
            destination_entity: KubernetesPod
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          # source KubernetesStatefulSet
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesStatefulSet
            destination_entity: KubernetesService
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesStatefulSet
            destination_entity: PublicNetworkLocation
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesStatefulSet
            destination_entity: KubernetesDeployment
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesStatefulSet
            destination_entity: KubernetesStatefulSet
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesStatefulSet
            destination_entity: KubernetesDaemonSet
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesStatefulSet
            destination_entity: KubernetesNode
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesStatefulSet
            destination_entity: KubernetesPod
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          # source KubernetesDaemonSet
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDaemonSet
            destination_entity: KubernetesService
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDaemonSet
            destination_entity: PublicNetworkLocation
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDaemonSet
            destination_entity: KubernetesDeployment
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDaemonSet
            destination_entity: KubernetesStatefulSet
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDaemonSet
            destination_entity: KubernetesDaemonSet
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDaemonSet
            destination_entity: KubernetesNode
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesDaemonSet
            destination_entity: KubernetesPod
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          # source KubernetesJob
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesJob
            destination_entity: KubernetesService
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesJob
            destination_entity: PublicNetworkLocation
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesJob
            destination_entity: KubernetesDeployment
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesJob
            destination_entity: KubernetesStatefulSet
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesJob
            destination_entity: KubernetesJob
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesJob
            destination_entity: KubernetesNode
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"
          - type: KubernetesCommunicatesWith
            source_entity: KubernetesJob
            destination_entity: KubernetesPod
            conditions: []
            context: "metric"
            attributes: [obi, tcp, http, grpc]
            action: "update"

  solarwindsentity/obi-entities:
    schema:
      entities:
        - entity: PublicNetworkLocation
          id:
            - sw.server.address.fqdn
      events:
        entities:
          - entity: "PublicNetworkLocation"
            context: "metric"
            action: "update"

service:
  extensions:
{{- if .Values.otel.gateway.sending_queue.offload_to_disk }}
    - file_storage/sending_queue
{{- end }}
    - health_check
{{- if .Values.diagnostics.profiling.enabled }}
    - pprof
{{- end }}
  pipelines:
    metrics/common_in:
      receivers:
        - otlp
      processors:
        - memory_limiter
      exporters:
        - routing/metrics
    metrics:
      receivers:
        - routing/metrics
      processors:
        - memory_limiter
{{- if .Values.otel.metrics.filter_histograms }}
        - filter/histograms
{{- end }}
{{- if .Values.ebpfNetworkMonitoring.reducer.telemetry.metrics.enabled }}
        - filter/otlp-metrics
{{- end }}
      exporters:
        - forward/metrics_common
    metrics/common_out:
      receivers:
        - forward/metrics_common
      processors:
        - memory_limiter
        - k8sattributes
{{- if .Values.otel.gateway.prefix }}
        - metricstransform/rename-following-otel-semantics
{{- end }}
        - attributes/clean-attributes-otlp-metrics
        - resource/clean-temporary-attributes
        - resource
        - transform/scope
        - batch
      exporters:
        - otlp
    logs:
      receivers:
        - otlp
      processors:
        - memory_limiter
        - k8sattributes
        - resource
        - transform/scope
        - batch
      exporters:
        - otlp
    traces:
      receivers:
        - otlp
      processors:
        - memory_limiter
        - k8sattributes
        - resource
        - transform/scope
        - batch
      exporters:
        - otlp

    # Current SWO pipeline cannot process state events and relationships events together,
    # so we need to split them into two separate pipelines.
    # TODO - merge 'logs/obi-stateevents-entities' and 'logs/obi-stateevents-relationships' into one pipeline when SWO supports it.
    metrics/obi-network-entities-and-relationships:
      receivers:
        - routing/metrics
      processors:
        - memory_limiter
        - swok8sworkloadtype/obi
        - transform/obi-fqdn-attribute
        - groupbyattrs/obi-entity-ids
        - transform/obi-entity-ids
        - transform/obi-relationship-types
        - groupbyattrs/obi-relationship-types
        - groupbyattrs/obi-entity-ids-after-transform
        - resource
      exporters:
        - forward/metrics_common
        - forward/obi-relationships
        - solarwindsentity/obi-entities
    metrics/obi-stateevents-relationships-filter-attributes:
      receivers:
        - forward/obi-relationships
      processors:
        - transform/obi-keep-only-entity-relation-attributes
        - filter/obi-self-loop-relationships
      exporters:
        - solarwindsentity/obi-relationships
    logs/obi-stateevents-entities:
      receivers:
        - solarwindsentity/obi-entities
      processors:
        - memory_limiter
        - transform/scope
        - logdedup/solarwindsentity
        - batch
      exporters:
        - otlp
    logs/obi-stateevents-relationships:
      receivers:
        - solarwindsentity/obi-relationships
      processors:
        - memory_limiter
        - transform/scope
        - logdedup/solarwindsentity
        - batch
      exporters:
        - otlp

  telemetry:
{{- if .Values.otel.gateway.telemetry.logs.enabled }}
    logs:
      level: {{ .Values.otel.gateway.telemetry.logs.level }}
{{- end }}
{{- if .Values.otel.gateway.telemetry.metrics.enabled }}
    metrics:
      readers:
        - pull:
            exporter:
              prometheus:
                host: {{ (split ":" .Values.otel.gateway.telemetry.metrics.address)._0 | quote }}
                port: {{ (split ":" .Values.otel.gateway.telemetry.metrics.address)._1 }}
{{- end }}